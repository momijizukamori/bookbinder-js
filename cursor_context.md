### Bookbinder JS – Context for Cursor

Note, this file was generated by an LLM.

This project is a JavaScript web app that performs “imposition” for bookbinding: it rearranges pages from a source PDF into printable sheets that fold into signatures (folios, quartos, octavos, sextodecimos) and some custom “wacky” layouts. It runs entirely in the browser using PDF-Lib, with a static HTML UI and Vite for local development and bundling.

### What the app does
- **Input**: a PDF file from the user.
- **Config**: user-selected printing and layout options (page size, layout type, margins, rotation, signature format, marks).
- **Process**: reorders pages, computes page positioning and scaling for the chosen layout, draws crop/fold/edge/sewing marks.
- **Output**: a preview and downloadable ZIP containing imposed PDFs (per-signature files and/or aggregate files).

### Where to start
- UI loads from `index.html`, which injects UI fragments and mounts `src/main.js` to wire everything up.
- `src/book.js` orchestrates the overall workflow: loading the PDF, computing page order/positions, building output PDFs, and previewing/saving.
- `src/models/configuration.js` defines the configuration schema (Zod), defaults, URL/localStorage persistence.
- Layout/page-order logic lives in `src/signatures.js` (classic signature/booklet/perfect) and `src/wacky_imposition.js` (custom strip layouts).
- Positioning and drawing helpers: `src/utils/layout.js`, `src/utils/pdf.js`, `src/utils/drawing.js`.

Key entry points:

```bookbinder-js/index.html
        <load src="src/html/file.html" />
        <load src="src/html/source_manip.html" />
        <load src="src/html/printer.html" />
        <load src="src/html/page_layout.html" />
        <load src="src/html/crop_box.html" />
        <load src="src/html/sig_format.html" />
        <load src="src/html/flyleaf.html" />
        <load src="src/html/preview.html" />
        <load src="src/html/buttons.html" />
```

### Domain concepts
- **Signature**: a group of folded sheets; typical formats are folio (2 pages per side), quarto (4), octavo (8), sextodecimo (16).
- **Folio/quarto/octavo/sextodecimo**: classic layouts each with its own fold sequence and per-sheet page count.
- **Booklet/perfect**: special cases of signature formatting and aggregation behavior.
- **Wacky layouts**: small multi-signature-per-sheet formats (e.g., 3/3/4, 6/10s, etc.) with explicit cut/fold diagrams.

Folding guidance for quarto/octavo (from the UI):

```bookbinder-js/src/html/page_layout.html
  <details>
    <summary>Folding instructions for quarto/octavo</summary>
    <p>
      Folding these two layouts is slightly more complex than the simple single-fold folio. Both of
      these have been designed so that the first fold is parallel to the short edge of the paper -
      eg, if you hold the page in portrait orientation, you will be folding the top edge to the
      bottom. One side of the page will have consecutive numbers across this fold (ie, 3 and 30 on
      the top row, 2 and 31). Fold inward across this line (so that 3 has been folded to lay against
      2, and 30 against 31). The next fold is along the other paper axis (parallel to the original
      long edge). For quarto, you want to find the side with the numbers closest together, and fold
      inwards to match them (this will be consecutive on the innermost sheet). For octavo, look at
      the bottom-most row and find the consecutive pair, then fold inward. Octavo has one last fold,
      for which you want to find the pair remaning that are closest, and fold them together.
    </p>
    <p>
      Or, if you want to just memorize the order, once you find the first fold side, the order
      is:<br />
      <b>quarto</b> - top to bottom, fold points away from you, left to right, fold points towards
      you.<br />
      <b>octavo</b> - top to bottom, fold points away from you, left to right, fold points away from
      you, top to bottom, fold points towards you.
    </p>
  </details>
```

### Architecture overview
- **Runtime**: Browser-based SPA over static HTML; Vite builds/injects HTML fragments and bundles modules.
- **Core orchestrator**: `Book` class (`src/book.js`)
  - Reads input PDF with `@cantoo/pdf-lib`
  - Normalizes pages (rotation/blank-page fix), tracks `cropbox`, `papersize`, and config
  - Selects a signature/imposition strategy:
    - “Classic”: `Signatures` (`booklet`, `perfect`, `standardsig`, `customsig`)
    - “Wacky”: `WackyImposition` (strip-based and multi-signature-per-sheet)
  - Computes page positions with `calculateDimensions`/`calculateLayout`
  - Draws fold/crop/edge/order/sewing marks
  - Builds preview and ZIP (via `JSZip` and `file-saver`)
- **UI and state flow**
  - `src/main.js` creates `Book` from configuration, attaches listeners, and reacts to user changes.
  - `src/utils/formUtils.js` bridges form ↔ config (Zod), persists to URL/localStorage.
  - `src/utils/renderUtils.js` updates preview info, dynamic selects, “wacky” toggles.
  - `src/utils/changeHandlers.js` and `src/utils/clickHandlers.js` wire form/input events to `Book`.

### Configuration model
- Defined in `src/models/configuration.js` with Zod; defaults provided and URL-safe parsing helpers.
- Persisted to URL query params and localStorage for deep-linkable, shareable configurations.
- Notable options:
  - `pageLayout`: `folio | quarto | octavo | sextodecimo`
  - `sigFormat`: classic vs wacky variants
  - `pageScaling`: `lockratio | stretch | centered`
  - `pagePositioning`: `centered | binding_aligned`
  - Sewing marks, cut/crop marks, PDF edge marks
  - Paper size (predefined or custom), printer duplex/rotation choices

### Layout definitions and page ordering
Classic layout cell grids and rotations are defined in `PAGE_LAYOUTS`:

```bookbinder-js/src/constants.js
  folio: {
    rotations: [[-90], [-90]],
    landscape: true,
    rows: 2,
    cols: 1,
    per_sheet: 4,
  },
  folio_alt: {
```

```bookbinder-js/src/constants.js
  quarto: {
    rotations: [
      [0, 0],
      [-180, -180],
    ],
    landscape: false,
    rows: 2,
    cols: 2,
    per_sheet: 8,
  },
  octavo: {
    rotations: [
      [-90, 90],
      [-90, 90],
      [-90, 90],
      [-90, 90],
    ],
    landscape: true,
    rows: 4,
    cols: 2,
    per_sheet: 16,
  },
```

Classic per-sheet page-order maps (1-indexed) live in `BOOKLET_LAYOUTS`; `Signatures.booklet(...)` applies them to compute front/back lists for each sheet in a signature. Perfect-bound uses its own maps in `PERFECTBOUND_LAYOUTS`.

“Wacky” layouts define strip/row builders and fold/cut lines in `src/wacky_imposition.js`, returning 2D sheet arrays for front/back rows with optional packing behavior (distributed vs packed gaps).

### Positioning, scaling, and marks
- `calculateDimensions(book)` determines per-cell size, page scaling (`lockratio`/`stretch`/`centered`), and margin-derived offsets.
- `calculateLayout(book)` expands the grid with per-position rotation and computed `x/y` coordinates (and spine mark anchors).
- Mark drawing in `src/utils/drawing.js`:
  - Crop marks and fold lines vary by `per_sheet`
  - Spine and signature-order marks: edge indicators for collating
  - Sewing marks: kettle/french-link points configurable by side and spacing

### Core flow (preview and export)
1. Load PDF; embed pages into a `managedDoc` (with optional source-rotation).
2. Build ordered page list, pad with blanks for flyleafs and to fill sheets.
3. Choose imposition strategy and compute `rearrangedpages` or rows/sheets.
4. Compute positioning/scale, then draw each page and marks onto output pages.
5. For preview: assemble the first signature/sheet into a single PDF and show it in an `<iframe>` via data URI.
6. For export: save per-signature or aggregate files to a ZIP and download.

### Tests and snapshots
- Unit and PDF visual tests with Vitest. Visual tests generate a PDF from a known input/config and compare against snapshot images using `pdf-visual-diff`.
- See `pdf-test/` for cases, helpers, and snapshot assets.

### How to add or modify a layout (classic)
- Add/adjust a layout in `PAGE_LAYOUTS` (rows/cols/per_sheet/rotations).
- Ensure page-order maps in `BOOKLET_LAYOUTS`/`PERFECTBOUND_LAYOUTS` match the `per_sheet` you support.
- UI: options already cover the classic four; changing defaults may require updating `src/html/page_layout.html` and `renderUtils`.
- Add visual tests (new case in `pdf-test/pdfTestCases.js`) and run `npm run test:pdf`.

### How to add a “wacky” layout
- Add a new builder in `WackyImposition` returning:
  - `sheetMaker(pageCount)`: 2D arrays of rows with page objects (front/back alternating).
  - `lineMaker()`: returns a function that emits fold/cut/crosshair lines.
  - `isLandscape` and `fileNameMod` metadata.
- Hook the builder in `Book.createoutputfiles`.
- Add the UI radio and instructions in `src/html/sig_format.html`.
- Add tests and snapshots for verification.

### Dev and build
- Commands (from README): `npm run dev`, `build`, `preview`, `test`, `test:unit`, `test:pdf`, `lint`, `prettier`.
- Served base path is configured in Vite: `base: 'https://momijizukamori.github.io/bookbinder-js/'`.
- No server runtime; all logic executes client-side with `@cantoo/pdf-lib`.

### Notable dependencies
- `@cantoo/pdf-lib`: PDF read/compose/draw APIs
- `zod`: robust, URL-safe configuration parsing
- `jszip` + `file-saver`: ZIP creation and download
- `vitest`, `jsdom`, `pdf-visual-diff`: testing and visual diffs

### Quick run
- `npm install && npm run dev`
- Open the URL printed by Vite, upload a sample PDF from `/docs`, choose a layout (start with folio), hit Preview/Generate.

### How `pagelistdetails` flows into folio vs quarto (classic layouts)
- What it is:
  - `Signatures.booklet(...)` returns, per signature, either:
    - `[frontSidePages, backSidePages]` for non-duplex, or
    - `[combinedFrontBack]` for duplex.
  - Each side is a flat list of PageInfo objects shaped like:
    - `info` (number | 'b'): source page index or blank
    - `isSigStart`, `isSigEnd`, `isSigMiddle`: signature position markers
    - `signatureNum`: 0-based signature index

- Where it’s produced:
  - The selected `pageLayout` sets `per_sheet` (folio=4, quarto=8, octavo=16, sextodecimo=32).
  - `BOOKLET_LAYOUTS[per_sheet]` provides the page-order maps (1-indexed) for front/back (and rotate).
  - `Signatures.booklet(...)` walks the source pages in innermost-to-outermost sheet order and emits PageInfo entries according to those maps, tagging `isSigStart`, `isSigEnd`, and the middle fold (`isSigMiddle`).
  - The result is stored in `signatures.pagelistdetails` and surfaced as `book.rearrangedpages`.

- How it’s consumed:
  1) `Book.generateClassicFiles(...)` → `createSignature(...)` → `writepages(...)` for front/back.
  2) `writepages(...)`:
     - Builds `filteredList` of numeric pages and remembers indices of `'b'` blanks.
     - Embeds pages into a fresh PDF; reinserts `'b'` holes so the side list and embeds stay aligned.
     - Computes `positions` from `calculateLayout(book)` which uses `PAGE_LAYOUTS` (rows/cols/rotations).
     - Splits the side list into blocks of `offset = per_sheet / 2`; each block corresponds to one physical sheet side and is drawn via `draw_block_onto_page(...)`.
  3) `draw_block_onto_page(...)`:
     - For each PageInfo in the block, draws the embedded page at `positions[i]` (x/y, scale, rotation).
     - Uses flags:
       - `isSigStart` → draw top spine edge mark; optionally draw signature-order bar (if enabled).
       - `isSigEnd` → draw bottom spine edge mark.
       - `isSigMiddle` and `sewingMarkLocation` control sewing mark placement (only on the non-spine page side).
       - `signatureNum` offsets the order mark so different signatures have distinct bar positions.

- Why folio vs quarto differs:
  - `per_sheet` controls both:
    - Which `BOOKLET_LAYOUTS[per_sheet]` map is used (logical page sequence within a sheet), and
    - The geometry of the grid from `PAGE_LAYOUTS[layout]`:
      - Folio: rows=2, cols=1 → 2 positions per side → `offset = 2`
      - Quarto: rows=2, cols=2 → 4 positions per side → `offset = 4`
      - Octavo: rows=4, cols=2 → 8 positions per side → `offset = 8`
      - Sextodecimo: rows=4, cols=4 → 16 positions per side → `offset = 16`
  - `writepages(...)` simply walks each side in `offset`-sized chunks and maps the i-th PageInfo in the chunk onto the i-th slot in the grid returned by `calculateLayout`. Thus the same `pagelistdetails` structure naturally renders into the correct physical arrangement for folio vs quarto, etc.


